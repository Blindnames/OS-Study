오늘의 주제는~

# Synchronization의 고전적 문제

## 1. Bounded-Buffer Problem
### 오류 발생 환경
버퍼가 유한한 환경에서 발생하는 문제

### 오류 1. 생산자-소비자 문제(Producer-Consumer Problem)

#### 오류 내용
1. 생산자, 소비자 두 종류의 여러 프로세스들이 존재
2. 생산자가 공유 버퍼에 데이터를 하나 만들어 집어넣음
3. 이 때, 두 가지 오류 발생 가능
	1) 생산자 문제 01: 비어있는 버퍼에 두 개 이상의 생산자가 동시에 데이터를 넣을 경우 오류 발생
	2) 소비자 문제 01: 두 개 이상의 소비자가 데이터를 꺼내올 때 오류 발생
	👉 1), 2) 해결 방법: Lock을 걸기
    
    3) 생산자 문제 02: 버퍼가 가득 찼는데 생산자가 데이터를 넣고자 할 경우 오류 발생
    👉 소비자 프로세스가 데이터를 가져가 빈 버퍼가 생길때까지 대기
    4) 소비자 문제 02: 버퍼가 비어있는데 데이터를 얻고자 할 경우 오류 발생
    👉 생산자 프로세스가 데이터를 넣어줄 때까지 대기
    

### 오류 2. Readers-Writers Problem
#### 오류 내용
1. readers와 writers라는 두 종류의 프로세스 존재, 공유데이터는 DB

2. 한 프로세스가 DB에 데이터를 쓰고(write) 있을 때 다른 프로세스 접근 시 오류
	✋but, 읽기(reader)는 동시에 여럿이 읽어도 됨
3. 해결 방법
:프로세스가 writer일 때 👉 아무도 접근하지 못하게 lock을 걸어줌 
프로세스가 reader일 때 👉 write에게만 lock을 걸기, 여러명의 reader가 와도 되기 때문에 reader에 대해서는 lock을 걸지 않는 것이 효율적

### 오류 3. Dining-Philosophers Problem
#### 배경상황
![](https://velog.velcdn.com/images/ofohj/post/94df7e02-4fd4-49e9-a741-22e25aea555f/image.png)

1. 위 사진과 같은 원탁에 다섯명의 철학자가 앉아있다.
2. 철학자는 생각하기 또는 밥먹기의 두 가지 일만 수행할 수 있다.
3. 밥을 먹을 때는 자신의 왼쪽, 오른쪽에 놓인 젓가락 중 하나만 사용할 수 있다.
4. 밥을 다 먹으면 젓가락을 내려놓고 다시 생각한다.

따라서, 공유자원은 '젓가락'이다.

이 상황에서는 deadlock(교착상태) 문제가 발생할 가능성이 있다.

📍 deadlock: 모든 철학자가 동시에 배가고파져 왼쪽 젓가락을 집으면 오른쪽 젓가락을 잡을 수가 없어진다.

👉 해결방안
- 4명의 철학자만 앉을 수 있게 한다
- 젓가락을 모두 잡을 수 있을 때에만 젓가락을 잡을 기회를 부여한다.
- 짝수 자리에 앉으면 왼쪽 젓가락을, 홀수 자리에 앉으면 오른쪽 젓가락을 잡을 수 있도록 한다.

---
이전 시간에 이렇게 공유자원을 관리하는 방법론을 Semaphore라고 했다.

이 방법에도 문제점이 발생할 수 있다.

# Semaphore의 문제점
- 코딩이 힘들다.
- 정확성의 입증이 어렵다.
- 한번의 실수가 모든 시스템에 치명적인 영향을 미친다.

---
# 해결책, monitor
그 해결 방안으로 monitor가 등장하였다.

## 특징
- 모니터 내에서는 한번에 하나의 프로세스만 활동 가능하다.
- 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 없다.

## semaphore vs monitor
### semaphore
세마포어는 생산자가 버퍼에 데이터를 넣기 위해 버퍼 전체에 **lock을 걸어** 다른 생산자의 접근을 막는다. 그 후 과정이 끝나면 **lock을 풀어**주는 방식으로 작동된다.

### monitor
한번에 하나밖에 활동하지 못하는 모니터의 특징 덕분에, **굳이 lock을 걸거나 푸는 코드가 필요하지 않다**. 예를 들어 생산자가 버퍼에 들어가있다면 다른 생산자는 대기열에 들어가 sleep 상태로 있으면 된다. 

---
#### 리뷰

💡 프로세스 동기화를 쉽게 말하면 **프로세스가 동시에 실행되면서 발생하는 문제를 해결**하는 것이다.
따라서, 이를 병행 제어(Concurrency Control)라고도 할 수 있다. 동기화 시 문제가 생기지 않도록 제어하는 역할을 하기 때문이다. 6-1장에서 그 문제를 다루었다.

6-2장에서는 동기화 문제 해결을 위한 수단으로 세마포어를 배웠다. 
이를 통해 변수 할당과 반납이 이루어지며 제어된다.

그 다음, 6-3장에서는 고전적 문제에 대해 세마포어를 활용한 해결방법을 배웠다.

---
출처: http://kocw.net/home/m/search/kemView.do?kemId=1046323