# 메모리
⚡**주소**를 통해 접근하는 매체

## 주소
- 논리적 주소 (가상주소)
: 프로그램이 실행되면 독자적인 주소공간 생성!
: CPU가 바라보는 주소

- 물리적 주소
: 실제 메모리의 주소

📍 주소 바인딩(결정)
: 프로그램 메모리를 물리적인 메모리의 어느 위치로 올릴지 결정하는 것
: symbolic address -> logical address -> physical address 순으로 올라감

📍 주소 변환
: 바인딩 과정에서 결정된 위치로 메모리를 올리는 과정

> 💡 주소 바인딩과 변환은 다르다! 
바인딩은 위치를 결정하는것, 변환은 메모리를 올리는 행위 그 자체!
👉 바인딩을 (**어디에**) 했다/ 변환을 **했다**!

- symbolic address
: 프로그래머가 쉽게 기억하고 사용할 수 있는 메모리 위치에 대한 이름
: 실제 메모리 주소 X, 소스 코드에서 사용되는 레이블!
ex) START

- logical address 
: OS가 메모리 위치를 나타내는 가상 주소
: CPU에 의해 생성 👉 메모리 관리 장치 (MMU)에 의해 물리 주소로 변환
ex) 0x1000

- physical address
: RAM의 메모리 위치의 실제 주소
: 물리 메모리의 메모리 셀을 고유하게 식별
ex) 0x401000

----
그럼 이 결정이 어떻게 이루어질까?
주소 바인딩을 자세히 살펴보도록 하자!

---
## 주소 바인딩
우선, 전체적인 순서도는 다음과 같다.
![](https://velog.velcdn.com/images/ofohj/post/1b6bb314-9480-44ac-a6be-162085683693/image.png)


- Compile time binding
: 컴파일시에 주소 결정(절대위치 부여)
: 컴파일 주소를 변경하고싶다면, 새로 컴파일이 이루어져야 함
: 현대 컴퓨터에는 사용되지 않음(비효율적)

- Load time binding
: 프로그램 실행이 시작될 때 결정

- Run time binding(Execution time binding)
: load time과 마찬가지로 실행이 시작될 때 결정
: 다만 프로그램 실행 중간에 주소 변환 가능
: 하드웨어적인 지원 필요

### MMU
#### 개념
주소를 변환해주는 하드웨어

#### 구성 요소
- Relocation register (base register)
: 접근할 수 있는 물리적 메모리 주소의 최소값

- Limit register
: 논리적 주소의 범위

#### 주소 변환을 위한 하드웨어적 지원
- 운영체제 및 사용자 프로세스 간의 메모리 보호를 위해 사용되는 레지스터
- 논리 주소의 범위를 벗어나는 값(악의적인 프로그램)이 들어오면 이를 식별해 접근을 막음

![](https://velog.velcdn.com/images/ofohj/post/bb91e0ca-4d2a-453e-a464-b36417a9eda9/image.png)

---
메모리 관련 용어 4가지를 배웠다!
## 1. Dynamic Loading
- 프로세스 전체를 메모리에 미리 다 올려놓지 않고 해당 루틴이 불려질(필요할) 때 메모리에 load한다.
👉 가끔씩 사용되는 많은 양의 코드가 있는 경우 유용
👉 쓸 것만 불러와 매우 효율적!

- os 라이브러리를 사용해 프로그래머가 직접 구현

## 2. Overlay
- 프로세스 부분 중 실제 필요한 정보만을 메모리에 올림
 👉dynamic loading과 유사하지만 os 지원 측면에서 차이가 있음!
 
- os의 지원을 받지 X

## 3. Swapping
- 프로세스를 일시적으로 메모리에서 **backing store**(하드디스크 등)로 쫓아내는 것

📍 backing store(swap area)
: 쫓겨난 프로세스를 저장하는 공간
: 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장공간 보유

- 상태
    (1) 쫓겨남: swap-out
    (2) 다시 들어옴: swap-in
    ![](https://velog.velcdn.com/images/ofohj/post/e0e483b5-ef31-44a5-8c94-0736e85c3a1c/image.png)

- compile time, load time binding에서는 원래 메모리 위치로 swap-in
- run time binding에서는 빈 메모리 영역 아무곳에나 올릴 수 있음

## 4. Dynamic Linking
📍 linking: 여러 곳에 존재하는 컴파일된 파일들을 한데묶어 실행파일로 만드는 작업

#### 개념
- 프로그램이 실행되는 도중에 라이브러리(shared library) 파일을 연결하는 방식

#### 효과
- 프로그램의 크기축소
- 여러 프로그램에서 공통적으로 사용되는 라이브러리의 효율적 관리 가능

#### 정적 링킹 VS 동적 링킹
동적 링킹의 유연성이 더 높다!
- 정적 링킹: 라이브러리를 컴파일 시점에 로드
👉 프로그램이 컴파일된 이후에 라이브러리 업데이트 및 변경 불가
- 동적 링킹: 라이브러리 실행 시점에 로드
👉 라이브러리 업데이트 및 변경 불가

---
## 물리적 메모리 할당
⚡ 메모리는 **OS 상주 영역**(낮은 주소 영역)과 **사용자 프로세스 영역**(높은 주소 영역)으로 나뉘어 사용

### 사용자 프로세스 영역 할당 방법
#### Contiguous allocation(연속적 할당)
프로그램이 메모리에 올라갈 때 통채로 올라감(지금까지 소개된 방식)

![](https://velog.velcdn.com/images/ofohj/post/39a062d9-df8a-48b6-b711-8d08f16e262f/image.png)

📍 연속적 할당 방식은 또 두 가지로 나뉜다.
- 고정 분할 방식: 메모리가 올라갈 공간을 미리 분할
- 가변 분할 방식: 프로그램이 실행될 때 마다 크기에 맞게 분할
</br>

📍 분할 과정에서 발생할 수 있는 문제는 다음과 같다.
- 외부조각: 들어오려는 프로그램의 크기가 분할된 크기보다 커서 사용되지 않은 공간
- 내부조각: 들어온 프로그램의 크기가 분할된 크기보다 작아 남은 공간

#### Noncontiguous allocation(불연속적 할당)
: 프로그램을 구성하는 주소 공간을 쪼개 하나의 프로세스가 분산되어 올라감

📍 이 할당 또한 세 가지의 방식으로 나뉜다. 다음 시간에 더 자세히! 오늘은 간단하게~
- Paging: 같은 크기의 페이지로 분할
- Segmentation: 크기가 아닌 유의미한 단위(code, data, stack)로 공간을 분할
- Paged Segmentation: (paging + segmentation) 하나의 segment를 여러개의 페이지로 구성

---

출처: http://kocw.net/home/m/search/kemView.do?kemId=1046323