## 동기식 입출력(Synchronous I/O)
*synchronous: 동시 발생(존재)하는 (ex. 립싱크)

- I/O 요청 후 작업이 완료가 되어야 사용자 프로그램에 넘어감

### 구현 방법 1
1) I/O가 끝날 때까지 cpu 낭비
2) 매 시점 하나의 I/O만 발생 가능

1번 방법은 낭비가 심하다. 이 방법말고 다른건?

### 구현 방법 2
1) I/O가 끝날때까지 해당 프로그램에게서 cpu 압수!
2) I/O 처리 대기줄에 해당 프로그램 줄 세우기
3) 그동안 다른 프로그램에게 cpu 할당

## 비동기식 입출력(Asynchronous I/O)
- I/O와 무관하게 작동
- I/O의 작업이 끝나지 않아도 제어가 사용자 프로그램에 즉시 넘어감

📍두 방식 모두 I/O의 완료는 **인터럽트**가 알려줌

## Instruction
- CPU만 접근 가능한 inst.
- I/O 장치에만 접근 가능한 inst.


## 프로그램 실행 방식
1) 프로그램은 보통 파일 시스템에 저장 (전원이 나가도 저장되어있음: 비휘발성)

2) 저장된 파일 실행

3) 파일이 메모리로 올라가 프로세스 진행
- (1) 가상메모리에 먼저 도달
- (2) 주 메모리에 도달
- 각 메모리는 code/data/stack 으로 이루어짐
- 파일이 올라올때마다 자동으로 메모리 생성

4) 주소 변환
변환 과정에서 가상 혹은 주 메모리에 담긴 데이터 중 
- 꼭 필요한 것: 물리적 메모리(구성: user,커널 영역)로 전달
- 덜 중요하지만 버리면 안되는 것: swap area로 전달 (전원이 나가면 잊음)


## 커널 주소 공간 구조
물리적 메모리 안에 있는 커널의 공간 구조는 다음과 같다.
- code
- data
- stack

### code
- 시스템 콜, 인터럽트 처리 코드
- 자원 관리 코드

### data
- CPU
- 메모리
- disk
- 프로세스마다 운영체제를 관리하기 위한 자료구조(PCB)

### stack
