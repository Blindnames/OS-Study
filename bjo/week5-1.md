목적 :

🔎 프로세스 생성에 대해 이해하기 위해

​

프로세스가 생성될 땐 부모 프로세스가 자식 프로세스를 생성합니다.

이 때 부모 프로세스가 직접 생성하는 것이 아니라

System Call을 통해 운영체제에게 요청하여 자식 프로세스를 생성합니다.

(생성하는 방법은 복제생성입니다..!)

​

그럼 복제 생성은 어떻게 될까요?

부모프로세스의 주소공간 내용을 그대로 자식 프로세스의 주소공간으로 복사한다. (Fork)

부모 프로세스와는 다른 자식프로세스의 프로그램을 실행해야할 경우 복제된 주소공간 위에 새로운 프로그램의 주소공간을 덮어씌어 실행한다. (Exec)

​

(1단계 복제 -> 2단계 덮어씌우기)

​

프로세스와 관련한 System Call

[fork() System Call]


부모 프로세스가 fork를 하면

자식 프로세스는 부모 프로세스의 문맥을 그대로 받아옵니다.!

그래서 자식 프로세스의 실행 시점은 맨 첫줄 main부터가 아닌

fork이후 입니다(이유는 program counter를 복제해서 실행하기 때문입니다..!) 

​

[exec() System Call]

어떤 프로그램을 완전히 새로운 프로세스로 태어나게 하는 역할을 합니다. 


execlp 이후의 나오는 코드는 실행이 안됩니다.

​

[wait() System Call]

자기 자식이 종료될 때까지 기다리는 시스템 콜


[exit() System Call]

프로세스를 종료시키는 시스템 콜

자발적 종료

마지막 statement 수행 후 exit() 시스텔 콜을 통해

프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌

비자발적 종료

부모 프로세스가 자식 프로세스를 강제 종료시킴

자식 프로세스가 한계치를 넘어서는 자원 요청

자식에게 할당된 Task가 더 이상 필요하지 않음

키보드로 kill,break를 친경우

부모가 종료하는 경우

부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨

​

프로세스 간 협력

(프로세스는 독립적으로 생성되고 자기일을 하지만

경우에 따라서 프로세스 간 협력을 해야지 효율적으로 실행되는 경우가 있다고 합니다.!)

독립적 프로세스(Independent process)

프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함

협력 프로세스(Cooperating process)

프로세스 협력 매커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

프로세스 간 협력 매커니즘(IPC : Interprocess Communication)

메시지를 전달하는 방법

message passing : 커널을 통해 메시지 전달

주소 공간을 공유하는 방법

shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 매커니즘이 있음 (원칙적으로는 프로세스는 독자적인 주소공간은 갖음)

thread : thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능


​

​

​

출처: http://kocw.net/home/search/kemView.do?kemId=1046323

강의: 이화여자대학교, 반효경(운영체제)