목적 :

운영체제가 자원관리를 어떻게 하는지 알아보기 위해서

​

[운영체제란?]

운영체제는 컴퓨터 내의 하드웨어와 사용자 및 다른 모든 소프트웨어를 관리시켜주는

하드웨어 바로 윗단에 설치되어 있는 소프트웨어입니다. 

ex) Windows, Max OS, Linux, Unix, Android, IOS 등


[운영체제의 자원 관리기능]

운영체제의 가장 핵심적인 기능은 자원을 효율적으로 관리하는 것입니다.

여기서 말하는 자원이란 2가지로 구분됩니다.

HW 자원 (OS의 아랫단 CPU/Memory/주변장치 or 입출력 장치)

SW 자원 (OS의 윗단)

​

(예전에는 하나의 운영체제가 하나의 프로그램밖에 관리를 못했다고 합니다..

근데 요즘에는 하나의 운영체제가 여러개의 프로그램을 관리할 수 있기 때문에..) 

​

[운영체제의 CPU 관리]

CPU의 경우 컴퓨터 한 대에 한개가 장착되기 때문에 여러 프로세스가 CPU를 효율적으로 나누어서

사용해야 합니다. 운영체제는 CPU 스케줄링을 통해서 매 시점 프로세스에 CPU를 할당하여 작업을

처리할 것인지 결정합니다.

​

​

대표적으로는 선입선출, 라운드 로빈, 우선순위 기법이 있습니다.

선입선출 스케줄링(First In First Out Scheduling)

선입선출 스케줄링은 먼저 온 프로세스를 먼저 처리해 주는 방식입니다.

⚠️ 만약에 처음에 작업 시간이 긴 프로세스가 오면 나머지는 그 프로세스가 끝날 때 까지 기다려야 하므로

어느정도 비효율은 감안해야 합니다. 

(실제로 queue자료구조가 cpu관리에 활용된다고 하네요!)

https://shineild-security.tistory.com/124

 
[자료구조] 큐(Queue)에 대해서 알아보자
주요 특징 1. FIFO(First-in, First-out) 더운 여름날 아마X빈에서 버블티를 사서 먹는 상상을 해보자. 빨대로 빨려 들어오는 타피오카 펄을 먹으며 우리는 큐를 생각해 낼 수 있다. 그것은 바로 선입선출의 과정을 진행하는 큐이다. 선입선출이란 우리가 빨대로 먹는 펄처럼 먼저 빨대에 들어온 녀석이 먼저 내 입에 들어온다는 법칙이다. 이 법칙은 판매업을 하는 가게에서 철칙으로 사용될 정도로 널리 사용되고 있으며 장점은 명확하다. 바로 제품의 신선도. 즉, 경우에 따라서 순환이 이루어 지지 못하는 스택과는 다르게 큐는 ...

shineild-security.tistory.com

2. 라운드 로빈 스케줄링(Round Robin Scheduiling)

라운드 로빈 스케줄링은 시분할 시스템을 위해 설계된 스케쥴링의 하나입니다.

​

(하나의 CPU는 같은 시점에서 여러 개의 작업을 동시에 수행할 수없기 때문에 CPU의 전체 사용량을 작은

작업시간 단위로 쪼개어 그 사간량 동안만 번갈아가면서 CPU를 할당하여 작업을 처리합니다..

이를 통해 실제로는 여러명의 사용자가 하나의 컴퓨터를 공유하여 사용하지만 각 사용자에게

자신만이 컴퓨터를 사용하고 있는 환상을 준다고 합니다)

​

프로세스들 사이에 우선순위를 두지 않고, 순서대로 즉 시간단위로 공평하게 CPU를 할당하는 방식입니다.

⚠️ 여기서 한번 할당된 CPU는 대기열의 제일 뒤로 가서 대기하게 되기때문에, 라운드 로빈방식에서는 시간단위를 어떻게 정할지가 가장 고려해야될 사항입니다.

​

​

3. 우선순위 스케줄링(Priority Scheduiling)

우선순위 스케줄링은 대기중인 프로세스들에게 우선순위를 부여하고 우선순위에 따라 높은 우선순위 먼저

CPU에 할당하는 방법입니다. 

⚠️ 이런 경우엔 우선순위가 낮은 프로세스는 CPU를 할당 받을 수 없으니,

기다린 시간이 늘어날 수록 우선순위를 높이는 방법도 생각해야 합니다.

(실제로 heap자료구조가 cpu관리에 활용된다고 하네요!) 

https://velog.io/@inyong_pang/16%EA%B0%95-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90Priority-Queues

 
[16강] 우선순위 큐(Priority Queues)
큐가 FIFO(First-In-First-Out) 방식을 따르지 않고 원소들의 우선순위에 따라 큐에서 빠져나오는 방식대표적인 응용 예로는 운영체제에서 CPU 스케줄러를 구현할 때 현재 실행할 수 있는 작업들 중 가장 우선순위가 높은 것을 골라 실행하는 알고리즘을 들 수

velog.io

​

​

[운영체제의 Memory관리]​

여러프로그램이 동시에 실행이 되려면 각 프로그램이 메모리공간을 조금씩 가지고 있어야 합니다.

메모리가 많이 필요한 프로그램이 있을 것이고 적게 필요한 프로그램이 있을것이고..

프로그램이 너무 많이 실행되면 메모리 분배 문제가 날수도 있을 것 같습니다.

이런 것 또한 관리해 주는 것이 운영체제의 역할인데 운영체제는 이 문제를 어떻게 효율적으로

관리할까요?

​

​

고정분할 방식

운영체제는 물리적 메모리를 몇 개의 분할(N개)로 미리 나누어 관리합니다.

⚠️이 방식은 동시 적재되는 최대 프로그램의 수가 분할 개수(N개)로 한정되기 때문에 가변방식에 비해 

융통성이 없습니다. 또한, 분할 크기보다 큰 프로그램은 적재가 불가능하기 때문에 여러가지 문제점이 발생하고, 분할 크기보다 작거나 큰 프로그램이 적재되면, 남는 영역인 내부조각과 맞는 메모리공간이 없어 외부조각  발생하게 됩니다.

내부조각 : 프로그램이 할당 되었지만 사용되지 않는 메모리영역

외부조각 : 맞는 메모리공간이 없어 할당되지 않는 프로세스


https://zangzangs.tistory.com/133

​

2. 가변분할 방식

운영체제는 매 시점 프로그램의 크기에 맞게 메모리를 반할해서 사용하는 방식을 말합니다.

분할이 프로세스보다 크기 때문에 큰 프로그램의 실행이 제한되는 문제는 발생하지 않지만, 

⚠️ 물리적 메모리보다 큰 프로그램의 실행은 여전히 불가능합니다. 또한, 분할의 크기와 개수가 동적으로 변하기 때문에 기술적 관리 기법이 필요합니다. 내부 조각은 발생하진 않지만, 메모리에 존재하는 프로그램이 종료되고 메모리 공간이 충분하지 않을 경 외부 조각이 발생하게 됩니다.

​

3. 가상 메모리 방식 (Virtual Memory System)

(애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 최소한 얼마만큼의 메모리가 필요한가에 집중하여 문제를 해결하고자 했다네요..)

운영체제는 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원합니다.

모든 프로그램은 물리적 메모리와는 독립적으로 자신만의 가상 메모리 주소를 갖게되고, 운영체제는

이 가상메모리의 주소를 물리적 주소로 매핑하는 기술을 이용해 주소로 변환시킨 후 프로그램을

물리적 메모리에 올리게됩니다. 프로그램의 전체 크기가 물리적 메모리보다 크더라도 현재 사용되고 있는

부분만 메모리에 올리고, 나머지는 Hard-Disk 같은 보조 기억장치에 저장해두었다가 필요할 때 적재하는 방식을 취합니다. 보조기억 장치의 영역을 스왑 영역이라고 부르며, 가상메모리 주소 공간의 페이지라는 동일한 크기의 작은 단위로 나뉘어 스왑 영역에 저장됩니다. 이렇게 동일한 단위로 메모리를 나누는 기법을

페이징 기법이라고 합니다.

​

디스크 관리와 입출력장치 관리는 또 나중에 배운다고 하니

운영체제의 CPU,MEMORY관리방법을 끝으로 마무리 하겠습니다.

출처: http://kocw.net/home/search/kemView.do?kemId=1046323

강의: 이화여자대학교, 반효경(운영체제)
[출처] [OS] 운영체제의 자원관리 기능|작성자 배준오